<!-- This file contains the custom HTML/CSS/JS box plot implementation that was previously used in unified_jk_view.html -->

<!-- Yield Distribution by Bucket -->
<div class="card mb-4">
    <div class="card-header">
        <h5 class="mb-0">Yield Distribution by Bucket (Box Plot) - Custom Implementation</h5>
    </div>
    <div class="card-body">
        <div class="box-plot-container" style="height: 400px; position: relative; overflow: hidden; padding-left: 60px; padding-right: 20px;">
            <div class="y-axis" style="position: absolute; left: 15px; top: 60px; bottom: 140px; display: flex; flex-direction: column; justify-content: space-between; color: white; font-size: 12px;">
                <!-- Y-axis labels will be dynamically generated by JS -->
            </div>
            <div class="chart-area" style="position: absolute; left: 60px; right: 20px; top: 60px; bottom: 140px; display: flex; align-items: flex-end; justify-content: space-around;">
                <!-- Box plots will be dynamically generated by JS -->
            </div>
            <div class="x-axis" style="position: absolute; left: 60px; right: 20px; bottom: 100px; display: flex; justify-content: space-around; color: white; font-size: 12px; text-align: center;">
                <!-- X-axis labels will be dynamically generated by JS -->
            </div>
            <div id="boxPlotTooltip" style="position: absolute; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 8px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 1000; display: none;"></div>
        </div>
    </div>
</div>

<style>
    /* Custom Box Plot Styles */
    .box-plot-container {
        background-color: #333; /* Dark background for the chart area */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .box-plot-item {
        position: relative;
        width: 50px; /* Width of each box */
        margin: 0 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end; /* Align to bottom for correct Y-axis mapping */
        height: 100%; /* Take full height of chart-area */
    }

    .whisker {
        position: absolute;
        width: 2px;
        background-color: white;
        left: 50%;
        transform: translateX(-50%);
    }

    .whisker-end {
        position: absolute;
        width: 20px;
        height: 2px;
        background-color: white;
        left: 50%;
        transform: translateX(-50%);
    }

    .box {
        position: absolute;
        width: 40px;
        background-color: #00a884; /* Teal color for the box */
        border: 1px solid #007a63;
    }

    .median-line {
        position: absolute;
        width: 40px;
        height: 2px;
        background-color: white;
        left: 50%;
        transform: translateX(-50%);
    }

    .mean-line {
        position: absolute;
        width: 40px;
        height: 2px;
        background: repeating-linear-gradient(90deg, white, white 2px, transparent 2px, transparent 4px); /* Dotted line */
        left: 50%;
        transform: translateX(-50%);
    }

    .x-axis-label {
        white-space: normal; /* Allow text to wrap */
        word-wrap: break-word; /* Break long words */
        max-width: 100px; /* Limit width to prevent overflow */
        overflow: hidden;
        text-overflow: ellipsis;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const boxPlotData = {{ bucket_analysis.bucket_analysis | tojson }};
    const chartArea = document.querySelector('.chart-area');
    const yAxisDiv = document.querySelector('.y-axis');
    const xAxisDiv = document.querySelector('.x-axis');
    const boxPlotTooltip = document.getElementById('boxPlotTooltip');

    if (!chartArea || !yAxisDiv || !xAxisDiv || !boxPlotTooltip) {
        console.error("Chart elements not found.");
        return;
    }

    // Filter out buckets with no yield data
    const validBoxPlotData = boxPlotData.filter(bucket => bucket.yields && bucket.yields.length > 0);

    if (validBoxPlotData.length === 0) {
        chartArea.innerHTML = '<p style="color: white; text-align: center; margin-top: 50px;">No complete yield data available for box plot.</p>';
        yAxisDiv.innerHTML = '';
        xAxisDiv.innerHTML = '';
        return;
    }

    // Calculate overall min and max yield for Y-axis scaling
    const allYields = validBoxPlotData.flatMap(bucket => bucket.yields);
    const maxYield = Math.max(...allYields);
    const minYield = Math.min(...allYields);
    const yieldRange = maxYield - minYield;

    console.log("Y-axis Debug:", { maxYield, minYield, yieldRange, boxPlotData: validBoxPlotData });

    // Define chart height for scaling
    const chartHeight = chartArea.clientHeight; // This should be 360px based on parent div height - (top + bottom)

    // Calculate Y-axis tick values based on actual data range
    const yAxisTicks = [
        maxYield,
        minYield + (yieldRange * 0.75),
        minYield + (yieldRange * 0.5),
        minYield + (yieldRange * 0.25),
        minYield
    ];

    // Ensure ticks are within a reasonable range and formatted
    yAxisDiv.innerHTML = yAxisTicks.map(tick => `<div>${tick.toFixed(1)}%</div>`).join('');
    console.log("Y-axis ticks:", yAxisTicks.map(tick => `${tick.toFixed(1)}%`));

    let boxPlotHTML = '';
    let xAxisLabelsHTML = '';

    validBoxPlotData.forEach((bucket, index) => {
        const yields = bucket.yields.sort((a, b) => a - b);
        const n = yields.length;

        // Calculate quartiles
        const q1 = yields[Math.floor(n * 0.25)];
        const median = yields[Math.floor(n * 0.5)];
        const q3 = yields[Math.ceil(n * 0.75) - 1];
        const mean = bucket.yield_mean; // Use the pre-calculated mean

        const min = bucket.yield_min;
        const max = bucket.yield_max;

        // Map yield values to pixel positions
        // The chart area height is 360px. 0% yield maps to bottom (0px), maxYield maps to top (360px)
        const scaleFactor = chartHeight / yieldRange;

        const minY = (min - minYield) * scaleFactor;
        const maxY = (max - minYield) * scaleFactor;
        const q1Y = (q1 - minYield) * scaleFactor;
        const medianY = (median - minYield) * scaleFactor;
        const q3Y = (q3 - minYield) * scaleFactor;
        const meanY = (mean - minYield) * scaleFactor;

        console.log(`Box plot positions for ${bucket.room_count}BR ${bucket.area_bucket} :`, { min, max, minY, maxY });

        // Ensure positions are within bounds
        const clampedMinY = Math.max(0, minY);
        const clampedMaxY = Math.min(chartHeight, maxY);
        const clampedQ1Y = Math.max(0, q1Y);
        const clampedMedianY = Math.max(0, medianY);
        const clampedQ3Y = Math.min(chartHeight, q3Y);
        const clampedMeanY = Math.max(0, Math.min(chartHeight, meanY));


        // Calculate heights and positions for CSS
        const boxHeight = Math.abs(clampedQ3Y - clampedQ1Y);
        const boxBottom = clampedQ1Y; // Position from the bottom of the chart area

        const whiskerMinHeight = clampedQ1Y - clampedMinY;
        const whiskerMaxHeight = clampedMaxY - clampedQ3Y;

        boxPlotHTML += `
            <div class="box-plot-item" data-index="${index}">
                <div class="whisker" style="height: ${whiskerMinHeight}px; bottom: ${clampedMinY}px;"></div>
                <div class="whisker-end" style="bottom: ${clampedMinY - 1}px;"></div> <!-- Adjusted for alignment -->
                <div class="box" style="height: ${boxHeight}px; bottom: ${boxBottom}px;"></div>
                <div class="median-line" style="bottom: ${clampedMedianY}px;"></div>
                <div class="mean-line" style="bottom: ${clampedMeanY}px;"></div>
                <div class="whisker" style="height: ${whiskerMaxHeight}px; bottom: ${clampedQ3Y}px;"></div>
                <div class="whisker-end" style="top: -1px;"></div> <!-- Adjusted for alignment -->
            </div>
        `;

        xAxisLabelsHTML += `
            <div class="x-axis-label">
                ${bucket.room_count}BR ${bucket.area_bucket}
            </div>
        `;
    });

    chartArea.innerHTML = boxPlotHTML;
    xAxisDiv.innerHTML = xAxisLabelsHTML;

    console.log("Found box items:", chartArea.children.length);

    // Tooltip functionality
    const boxPlotItems = document.querySelectorAll('.box-plot-item');
    boxPlotItems.forEach(item => {
        const index = parseInt(item.dataset.index);
        const bucket = validBoxPlotData[index];
        console.log("Setting up tooltip for item:", index, `${bucket.room_count}BR ${bucket.area_bucket}`);

        item.addEventListener('mousemove', function(e) {
            const yields = bucket.yields.sort((a, b) => a - b);
            const n = yields.length;
            const q1 = yields[Math.floor(n * 0.25)];
            const median = yields[Math.floor(n * 0.5)];
            const q3 = yields[Math.ceil(n * 0.75) - 1];
            const mean = bucket.yield_mean;
            const min = bucket.yield_min;
            const max = bucket.yield_max;
            const iqr = q3 - q1;

            boxPlotTooltip.style.left = `${e.pageX + 10}px`;
            boxPlotTooltip.style.top = `${e.pageY + 10}px`;
            boxPlotTooltip.style.display = 'block';
            boxPlotTooltip.innerHTML = `
                <strong>${bucket.room_count}BR ${bucket.area_bucket}</strong><br>
                Min: ${min.toFixed(1)}%<br>
                Q1: ${q1.toFixed(1)}%<br>
                Median: ${median.toFixed(1)}%<br>
                Mean: ${mean.toFixed(1)}%<br>
                Q3: ${q3.toFixed(1)}%<br>
                Max: ${max.toFixed(1)}%<br>
                IQR: ${iqr.toFixed(1)}%<br>
                Rentals: ${bucket.rental_count}<br>
                Sales: ${bucket.sales_count}
            `;
        });

        item.addEventListener('mouseleave', function() {
            boxPlotTooltip.style.display = 'none';
        });
    });
});
</script> 